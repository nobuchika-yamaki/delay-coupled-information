import numpy as np
from scipy.signal import welch
from scipy.linalg import inv
import matplotlib.pyplot as plt

# ===============================
# 1. Model parameters (Methods 2.1–2.3)
# ===============================
alpha = 1.0
beta  = 1.0
gamma = 0.8

dt = 0.001
T_sim = 60.0
time = np.arange(0, T_sim, dt)
n_steps = len(time)

tau_c = 0.01  # inter-unit delay (s)

noise_std = 0.03
np.random.seed(0)

# ===============================
# 2. External input u(t) (Methods 2.4)
# ===============================
def generate_input():
    u = np.random.randn(n_steps)
    return u / np.std(u)

# ===============================
# 3. Delay-coupled dynamics (Methods 2.2–2.3)
# ===============================
def simulate(delta_tau, f1, f2):
    tau1 = tau_c + delta_tau / 2
    tau2 = tau_c - delta_tau / 2

    d1 = int(tau1 / dt)
    d2 = int(tau2 / dt)
    dc = int(tau_c / dt)

    x1 = np.zeros(n_steps)
    x2 = np.zeros(n_steps)

    u = generate_input()

    for t in range(max(d1, d2, dc), n_steps):
        x1[t] = (
            x1[t-1]
            + dt * (-alpha * x1[t-1]
            + beta * u[t]
            + gamma * x2[t-dc]
            + np.random.randn() * noise_std)
        )

        x2[t] = (
            x2[t-1]
            + dt * (-alpha * x2[t-1]
            + beta * u[t]
            + gamma * x1[t-dc]
            + np.random.randn() * noise_std)
        )

    return x1, x2

# ===============================
# 4. Effective timescale T0 (Methods 2.5)
# ===============================
def estimate_T0(x):
    f, Pxx = welch(x, fs=1/dt, nperseg=4096)
    f_peak = f[np.argmax(Pxx)]
    return 1.0 / f_peak

# ===============================
# 5. Integration and differentiation (Methods 2.6–2.8)
# ===============================
def integration_differentiation(x1, x2):
    r = np.corrcoef(x1, x2)[0,1]
    I_INT = r**2
    Q = 1 - I_INT
    return I_INT, Q

# ===============================
# 6. Fisher information (Methods 2.9)
# Gaussian Fisher information
# ===============================
def fisher_information(x1, x2):
    X = np.vstack([x1, x2])
    mu = np.mean(X, axis=1)
    Sigma = np.cov(X)
    return np.trace(inv(Sigma))

# ===============================
# 7. Parameter sweep (Methods 2.10–2.11)
# ===============================
delta_tau_vals = np.linspace(0.0, 0.20, 40)
delta_f_vals   = np.linspace(0.0, 6.0, 30)

C_map = np.zeros((len(delta_f_vals), len(delta_tau_vals)))
F_map = np.zeros_like(C_map)
T0_map = np.zeros_like(C_map)

for i, df in enumerate(delta_f_vals):
    for j, dtau in enumerate(delta_tau_vals):
        f1 = 4.0
        f2 = 4.0 + df

        x1, x2 = simulate(dtau, f1, f2)

        # discard transient
        x1 = x1[int(10/dt):]
        x2 = x2[int(10/dt):]

        T0 = estimate_T0(x1 + x2)
        T0_map[i, j] = T0

        I_INT, Q = integration_differentiation(x1, x2)
        C_map[i, j] = I_INT * Q
        F_map[i, j] = fisher_information(x1, x2)

# ===============================
# 8. Normalization and plotting
# ===============================
DT, DF = np.meshgrid(delta_tau_vals, delta_f_vals)
DT_norm = DT / np.mean(T0_map)

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

im0 = axes[0].contourf(DT_norm, DF, C_map, levels=30)
axes[0].axvline(0.25, linestyle="--")
axes[0].set_title("Coordination index C")

im1 = axes[1].contourf(DT_norm, DF, F_map, levels=30)
axes[1].axvline(0.25, linestyle="--")
axes[1].set_title("Fisher information F")

for ax in axes:
    ax.set_xlabel("Δτ / T₀")
    ax.set_ylabel("ΔF (Hz)")

plt.colorbar(im0, ax=axes[0])
plt.colorbar(im1, ax=axes[1])
plt.tight_layout()
plt.show()
